// 1. Є наступний код:

console.log('start'); //синхронний код

const promise1 = new Promise((resolve, reject) => {
console.log(1) // синхронний код, виконується одразу при створенні Promise
resolve(2) // //проміс переходить у стан fulfilled. код викнується при виклику then
})

promise1.then(res => { // стає в чергу, виконується після синхронного коду
console.log(res)
})

console.log('end'); // синхронний код


// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
// "start 1 end 2"



// 2. Є наступний код:

Promise.resolve(1) //проміс переходить у стан fulfilled
		.then((x) => x + 1) // повертає 2
		.then((x) => { throw new Error('My Error') }) // згенеровано вийняток, виконання then зупиняється. шукаємо catch.
		.catch(() => 1) // повертає 1. помилка оброблена, тому далі можемо шукати then
		.then((x) => x + 1) // повертає 2 (1+1)
		.then((x) => console.log(x)) // виводить "2" у консоль
		.catch(console.error) // пропускається, адже помилка вже була оброблена у попередньому catch


// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
// "2"


// 3. Є наступний код:

const promise = new Promise(res => res(2)); // проміс переходить у стан fulfilled
	promise.then(v => {
	        console.log(v); // виводить "2" у консоль
	        return v * 2; // повертає 4
	    })
	    .then(v => {
	        console.log(v); // виводить 4 у консоль
	        return v * 2; // повертає 8
	    })
	    .finally(v => { 
	        console.log(v); // виводить undefined, адже finally не приймає параметрів і не може змінити значення, що повертається
	        return v * 2; // значення, що повертає finally, ігнорується. (якщо це не проміс у стані rejected)
	    })
	    .then(v => {
	        console.log(v); // виводить 8 у консоль
	    });


// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
"2 4 undefined 8"